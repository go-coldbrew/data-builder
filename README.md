<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# databuilder

```go
import "github.com/go-coldbrew/data-builder"
```

## Index

- [Variables](<#variables>)
- [func AddResultToCtx(ctx context.Context, r Result) context.Context](<#func-addresulttoctx>)
- [func GetFromResult(ctx context.Context, obj interface{}) interface{}](<#func-getfromresult>)
- [func IsValidBuilder(builder interface{}) error](<#func-isvalidbuilder>)
- [type DataBuilder](<#type-databuilder>)
  - [func New() DataBuilder](<#func-new>)
- [type Plan](<#type-plan>)
- [type Result](<#type-result>)
  - [func GetResultFromCtx(ctx context.Context) Result](<#func-getresultfromctx>)
  - [func (r Result) Get(obj interface{}) interface{}](<#func-result-get>)


## Variables

```go
var (
    ErrInvalidBuilder               = errors.New("The provided builder is invalid")
    ErrInvalidBuilderKind           = errors.New("invalid builder, should only be a function")
    ErrInvalidBuilderNumOutput      = errors.New("invalid builder, should always return two values")
    ErrInvalidBuilderFirstOutput    = errors.New("invalid builder, first return type should be a struct")
    ErrInvalidBuilderSecondOutput   = errors.New("invalid builder, second return type should be error")
    ErrInvalidBuilderMissingContext = errors.New("invalid builder, missing context")
    ErrInvalidBuilderInput          = errors.New("invalid builder, input should be a struct")
    ErrMultipleBuilderSameOutput    = errors.New("invalid, multiple builders CAN NOT produce the same output")
    ErrSameInputAsOutput            = errors.New("invalid builder, input and output should NOT be same")
    ErrCouldNotResolveDependency    = errors.New("dependency can not be resolved")
    ErrMultipleInitialData          = errors.New("initial data provided twice")
    ErrInitialDataMissing           = errors.New("need complile time defined initial data to run")
)
```

## func AddResultToCtx

```go
func AddResultToCtx(ctx context.Context, r Result) context.Context
```

### AddResultToCtx adds the given result object to context

this function should ideally only be used in your tests and/or for debugging modification made to Result obj will NOT persist

## func GetFromResult

```go
func GetFromResult(ctx context.Context, obj interface{}) interface{}
```

### GetFromResult allows builders to access data built by other builders

this function enables optional access to data\, your code should not rely on values being present\, if you have explicit dependency please add them to your function parameters

## func IsValidBuilder

```go
func IsValidBuilder(builder interface{}) error
```

IsValidBuilder checks if the given function is valid or not

## type DataBuilder

```go
type DataBuilder interface {
    AddBuilders(fn ...interface{}) error
    Compile(initialData ...interface{}) (Plan, error)
}
```

### func New

```go
func New() DataBuilder
```

New Creates a new DataBuilder

## type Plan

```go
type Plan interface {
    Run(context.Context, ...interface{}) (Result, error)
}
```

## type Result

```go
type Result map[string]interface{}
```

### func GetResultFromCtx

```go
func GetResultFromCtx(ctx context.Context) Result
```

#### GetResultFromCtx gives access to result object at this point in execution

this function should ideally only be used in your tests and/or for debugging modification made to Result obj may or may not persist

### func \(Result\) Get

```go
func (r Result) Get(obj interface{}) interface{}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
